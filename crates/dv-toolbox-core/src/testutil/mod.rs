use core::str;
use std::{
    collections::{HashMap, HashSet},
    path::PathBuf,
    sync::LazyLock,
};

use data_encoding::{Encoding, HEXUPPER_PERMISSIVE};
use derive_more::{Deref, From};
use googletest::prelude::*;
use regex::Regex;

/// Directory containing test-related data files.
pub(crate) fn test_resource(path: &str) -> PathBuf {
    [env!("CARGO_MANIFEST_DIR"), "resources/test", path].iter().collect()
}

static PADDED_HEX: LazyLock<Encoding> = LazyLock::new(|| {
    let mut spec = HEXUPPER_PERMISSIVE.specification();
    spec.ignore = String::from(" ");
    spec.encoding().unwrap()
});

/// Parse a string like "AA BB CC DD EE" into a byte array
pub(crate) fn from_hex<const N: usize>(value: &str) -> [u8; N] {
    PADDED_HEX
        .decode(value.as_bytes())
        .expect("value should be a valid hexadecimal string")
        .try_into()
        .unwrap()
}

/// Map of test case name to test case data.  See the [`test_case_map`] macro for an example of how
/// to use this.
#[derive(Debug, Deref, From)]
pub(crate) struct TestCaseMap<'a, T>(HashMap<&'a str, T>);

impl<'a, T> TestCaseMap<'a, T> {
    /// Return test case given the test function name generated by rstest
    ///
    /// The parameter needs to be the return value of the [`stdext::function_name`] macro.  The
    /// macro must be called from within a `#[case]` attribute.  Do not call it from within your
    /// test function itself.
    ///
    /// Example input: `my_crate_name::my_module::tests::test_frob::case_1_success_if_foo` which
    /// will return `success`.
    pub(crate) fn get_test_case(&self, test_function_name: &'a str) -> &T {
        let case_name = &GET_TEST_CASE_RE.captures(test_function_name).unwrap()[1];
        assert!(self.contains_key(case_name), "Test case {case_name} is not in test table");
        &self[case_name]
    }
}

/// A lazy-initialized map of test cases.  See the [`test_case_map`] macro for an example of how to
/// use this.
pub(crate) type LazyTestCases<'a, T> = LazyLock<TestCaseMap<'a, T>>;

/// Lazy-initializes a map of [`rstest`] test cases for a given function.  Intended for use as a
/// static variable.
///
/// The advantage of using this over passing structures directly to `#[case]` is that the structures
/// will be auto-formatted with rustfmt.
///
/// # Examples
///
/// ```ignore
/// use rstest::rstest;
/// use stdext::function_name;
///
/// #[derive(Debug)]
/// struct FunctionATestCase {
///     foo: i32,
///     bar: i32,
/// }
///
/// static FUNCTION_A_TEST_CASES: LazyTestCases<FunctionATestCase> = test_case_map!(
///     "first_case",
///     FunctionATestCase { foo: 1, bar: 1 },
///     "second_case",
///     FunctionATestCase { foo: 2, bar: 2 }
/// );
///
/// #[rstest]
/// #[case::first_case(function_name!())]
/// #[case::second_case(function_name!())]
/// fn test_function_a(#[case] test_function_name: &str) {
///     let tc = FUNCTION_A_TEST_CASES.get_test_case(test_function_name);
///
///     assert!(tc.foo > 0);
/// }
///
/// // If you add an entry to FUNCTION_A_TEST_CASES but forget to add a #[case] for it, this will
/// // catch the mistake.
/// test_all_test_cases_ran!(
///     ("test_function_a", &FUNCTION_A_TEST_CASES)
/// );
/// ```
macro_rules! test_case_map {
    ($($test_case_name:expr, $test_case_data:expr),*) => {
        ::std::sync::LazyLock::new(|| ::std::collections::HashMap::<&str, _>::from([
            $(($test_case_name, $test_case_data)),*
        ]).into())
    };
}

pub(crate) use test_case_map;

/// Asserts that all [`rstest`] test cases in the given tables of test cases are actual test cases
/// in this test binary.
///
/// If you are using the [`test_case_map`] macro and [`TestCaseMap`] type, then you should also
/// call this macro to make sure that every entry in a [`TestCaseMap`] has a corresponding `case`
/// statement in [`rstest::rstest`].
///
/// # Examples
///
/// ```ignore
/// test_all_test_cases_ran!(
///     ("test_function_a", &FUNCTION_A_TEST_CASES),
///     ("test_function_b", &FUNCTION_B_TEST_CASES),
/// );
/// ```
macro_rules! test_all_test_cases_ran {
    ($($test_function_test_cases:expr),*) => {
        #[test]
        fn test_all_test_cases_ran() {
            let mut _expected_test_cases = ::std::collections::HashMap::<&str, Vec<&str>>::new();
            $({
                let (test_function_name, test_case_map) = $test_function_test_cases;
                _expected_test_cases
                    .insert(test_function_name, test_case_map.keys().map(|k| *k).collect());
            })*
            $crate::testutil::assert_all_test_cases_ran(&_expected_test_cases, module_path!());
        }
    };
}

pub(crate) use test_all_test_cases_ran;

static GET_TEST_CASE_RE: LazyLock<Regex> =
    LazyLock::new(|| Regex::new(r".+::case_\d*_([^:]+)$").unwrap());

static GET_CRATE_NAME_RE: LazyLock<Regex> = LazyLock::new(|| Regex::new(r"^[^:]+").unwrap());

static PARSE_TEST_LIST_RE: LazyLock<Regex> =
    LazyLock::new(|| Regex::new(r"^(.+)::case_\d*_(.+): test$").unwrap());

/// Asserts that all [`rstest`] test cases in the given tables of test cases are actual test cases
/// in this test binary.
///
/// The function is not generally to be used directly.  Use the [`test_all_test_cases_ran`] macro
/// instead.
pub(crate) fn assert_all_test_cases_ran(
    expected_test_cases: &HashMap<&str, Vec<&str>>,
    test_module_path: &str,
) {
    // final result for each set are paths like:
    // my_crate_name::my_module::tests::test_frob::success_if_foo

    // test cases built from the user's tast table HashMap
    let expected_test_cases = HashSet::<String>::from_iter(expected_test_cases.iter().flat_map(
        |(test_function_name, test_cases_for_function)| {
            test_cases_for_function.iter().map(move |test_case_name| {
                format!("{test_module_path}::{test_function_name}::{test_case_name}")
            })
        },
    ));

    let crate_name = GET_CRATE_NAME_RE.find(test_module_path).unwrap().as_str();

    // run the test executable to list all tests
    // the output of this command looks like:
    // my_module::tests::test_frob::case_02_success_if_foo: test
    let list_all_tests_output = std::process::Command::new(std::env::current_exe().unwrap())
        .args(["--list", "--format", "terse"])
        .output()
        .unwrap();
    assert_that!(
        list_all_tests_output.status.success(),
        eq(true),
        "Failed to run test EXE to list tests"
    );
    let actual_test_cases = HashSet::<String>::from_iter(
        str::from_utf8(&list_all_tests_output.stdout).unwrap().lines().flat_map(
            |test_output_line| {
                let parsed = PARSE_TEST_LIST_RE.captures(test_output_line)?;
                Some(format!("{crate_name}::{}::{}", &parsed[1], &parsed[2]))
            },
        ),
    );

    let unrun_test_cases: Vec<_> = expected_test_cases.difference(&actual_test_cases).collect();
    assert_that!(
        unrun_test_cases,
        empty(),
        "These test cases are not referenced by the test function with a #[case] attribute."
    );
}

mod tests {
    use googletest::expect_that;

    use super::*;

    #[googletest::test]
    fn test_from_hex() {
        expect_that!(from_hex("AA BB CC"), eq([0xAA, 0xBB, 0xCC]));
    }
}
